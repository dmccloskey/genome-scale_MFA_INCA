function [X,FVAL,LAMBDA,EXITFLAG] = LINPROG(F,A,B,varargin)
%MYLINPROG Customized implementation of MATLAB's LINPROG function.
%   X = MYLINPROG(F,A,B) solves the linear programming problem
% 
%             min F'*X    subject to:   A*X <= B
%              X
%
%   X = LINPROG(F,A,B,AEQ,BEQ) solves the problem above while additionally
%   satisfying the equality constraints AEQ*X = BEQ.
%
%   [X,FVAL,LAMBDA,EXITFLAG] = ... also returns the optimal function value,
%   Lagrange multipliers, and exit flag generated by LINPROG.
%
%   See also LINPROG, MYLSQLIN, FVA.

EXITFLAG = -2;
FVAL = 0;
X = [];
LAMBDA = [];

AEQ = [];
BEQ = [];
if nargin >3
    AEQ = varargin{1};
    BEQ = varargin{2};
end

% check the shape of the objective matrices
[c_rows,c_columns] = size(F);
if (c_rows>c_columns)
    [beq_rows,beq_columns] = size(BEQ);
    [b_rows,b_columns] = size(B);
    [nMets_eq,nRxns_eq] = size(AEQ);
    [nMets,nRxns] = size(A);
    c = F;
    A = [AEQ;A];
    b = [BEQ;B];
    lb_eq(1:nRxns_eq,1) = -1000;
    lb_in(1:nRxns,1) = -1000;
    lb = [lb_eq;lb_in];
    ub_eq(1:nRxns_eq,1) = 1000;
    ub_in(1:nRxns,1) = 1000;
    ub = [ub_eq;ub_in];
    csense_eq(1:nMets_eq,1) = 'E';
    csense_in(1:nMets,1) = 'L';
    csense = [csense_eq; csense_in];
    osense = 1;
else
    [beq_rows,beq_columns] = size(BEQ);
    [b_rows,b_columns] = size(B);
    [nMets_eq,nRxns_eq] = size(AEQ);
    [nMets,nRxns] = size(A);
    c = F';
    A = [AEQ;A];
    b = [BEQ;B];
    lb_eq(1:nRxns_eq,1) = 0;
    lb_in(1:nRxns,1) = 0;
    lb = [lb_eq;lb_in];
    ub_eq(1:nRxns_eq,1) = 1000;
    ub_in(1:nRxns,1) = 1000;
    ub = [ub_eq;ub_in];
    csense_eq(1:nMets_eq,1) = 'E';
    csense_in(1:nMets,1) = 'L';
    csense = [csense_eq; csense_in];
    osense = 1;
end

LPproblem.A = A;
LPproblem.c = c;
LPproblem.b = b;
LPproblem.lb = lb;
LPproblem.ub = ub;
LPproblem.csense = csense;
LPproblem.osense = osense;

%Double check that all inputs are valid:
if ~(verifyCobraProblem(LPproblem, [], [], false) == 1)
    warning('invalid problem');
    return;
end

%Call LP solver
solution = solveCobraLP(LPproblem);

objective = solution.obj;

if (solution.stat ~= 1) % check if initial solution was successful.
    warning('Optimal solution was not found');
    FBAsolution.f = 0;
    FBAsolution.x = [];
    FBAsolution.stat = solution.stat;
    FBAsolution.origStat = solution.origStat;
    FBAsolution.solver = solution.solver;
    
    % Convert FBAsolution to linprog solution
    if (solution.stat==0)
        EXITFLAG = -1;
    elseif (solution.stat==2)
        EXITFLAG = -3;
    elseif (solution.stat==-1)
        EXITFLAG = -2;
    end
    FVAL = 0;
    X = [];
    LAMBDA = [];
    
    return;
end

% Store results
if (solution.stat == 1)
    %solution found.
    FBAsolution.x = solution.full(1:nRxns);
    
    %this line IS necessary.
    FBAsolution.f = c'*solution.full(1:nRxns); %objective from original optimization problem.
    if abs(FBAsolution.f - objective) > .01
        display('warning:  objective appears to have changed while performing secondary optimization (minNorm)');
    end
    
    FBAsolution.y = solution.dual;
    FBAsolution.w = solution.rcost;

    EXITFLAG = 1;
    FVAL = c'*solution.full(1:nRxns);
    X = solution.full(1:nRxns);
    LAMBDA.ineqlin = solution.dual;
else
    %some sort of error occured.
    if printLevel>0
        warning('Optimal solution was not found');
    end
    FBAsolution.f = 0;
    FBAsolution.x = [];
    
    FVAL = 0;
    X = [];
    LAMBDA = [];
end

FBAsolution.stat = solution.stat;
FBAsolution.origStat = solution.origStat;
FBAsolution.solver = solution.solver;
